<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Othello - Player vs Player</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
          integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
          crossorigin="anonymous" referrerpolicy="no-referrer"/>
    <link rel="stylesheet" href="style.css">
    <style>
        /* Add specific styles for corner dots within this game page */
         .cell.corner-dot::after {
            content: "";
            display: block;
            width: 6px;
            height: 6px;
            background-color: black; /* Default black for corners */
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }


    </style>
</head>
<body>
<div class="score-board">
    <div id="black-score"></div> <!-- Will be updated by JS -->
    <div id="white-score"></div> <!-- Will be updated by JS -->
     <div id="timer" class="timer-display">--</div> <!-- Timer element -->
</div>

<!-- DROPDOWN MENU STRUCTURE -->
<div class="game-menu-dropdown">
    <button id="game-menu-button" class="dropdown-button" aria-haspopup="true" aria-expanded="false">
        <i class="fas fa-bars"></i> Menu
    </button>
    <div id="game-menu-content" class="dropdown-content">
        <a href="#" id="toggle-hints-dropdown">Hide Hints</a>
        <a href="#" id="restart-dropdown">Restart Game</a>
        <a href="index.html">Main Menu</a>
    </div>
</div>
<!-- END DROPDOWN MENU STRUCTURE -->

  <!-- The game board -->
  <div id="board" class="board"></div>
</div>

<!-- History Navigation Buttons -->
<div class="history-buttons">
    <button id="prev-move-btn" disabled><i class="fas fa-step-backward"></i> </button>
    <button id="next-move-btn" disabled><i class="fas fa-step-forward"></i></button>
</div>

<div id="skip-turn-overlay" class="skip-turn-overlay">
    <div id="skip-turn-popup" class="skip-turn-popup">
        <span id="skip-player-message">Player</span> Skipped Turn!
    </div>
</div>

<div id="game-over"></div>
<div id="skip-history-box">
    <h3>History:</h3>
    <ul id="skip-history-list"></ul>
</div>

<footer>
    <a style="color: rgb(175, 175, 175); text-decoration: none;" href="https://www.instagram.com/sidonstudio/">Developed
        by @SidonStudio</a>
</footer>
<script>
    // Define color themes - Ensure this object is consistent across all HTML files
     const colorThemes = {
            default: {
                'background-color-1': '#1f372b',
                'background-color-2': '#112719',
                'text-color': '#ffffff',
                'button-color': '#34d399',
                'button-text-color': '#1f2937',
                'button-hover-color': '#10b981',
                'board-color': '#059669',
                'scoreboard-text-color': '#ffffff',
                'skip-history-heading-color': '#ffffff',
                'skip-history-text-color': '#9ca3af',
                'piece-black-dark': '#000',
                'piece-black-light': '#444',
                'piece-white-dark': '#ddd',
                'piece-white-light': '#fff',
                'last-move-dot-color': '#ff0000',
                'timer-text-color': '#ffffff', /* Match default text */
                'timer-bg-color': 'rgba(0, 0, 0, 0.2)',
                'timer-border-color': 'rgba(0, 0, 0, 0.3)',
                'timer-low-color': '#ef4444'
            },
            dark: {
                'background-color-1': '#333333',
                'background-color-2': '#222222',
                'text-color': '#eeeeee',
                'button-color': '#555555',
                'button-text-color': '#ffffff',
                'button-hover-color': '#777777',
                'board-color': '#444444',
                'scoreboard-text-color': '#eeeeee',
                'skip-history-heading-color': '#eeeeee',
                'skip-history-text-color': '#9ca3af',
                'piece-black-dark': '#111',
                'piece-black-light': '#555',
                'piece-white-dark': '#ccc',
                'piece-white-light': '#eee',
                 'last-move-dot-color': '#ff0000',
                 'timer-text-color': '#eeeeee', /* Match dark text */
                 'timer-bg-color': 'rgba(0, 0, 0, 0.2)',
                 'timer-border-color': 'rgba(0, 0, 0, 0.3)',
                 'timer-low-color': '#ef4444'
            },
            forest: {
                'background-color-1': '#38593b',
                'background-color-2': '#2b3a2d',
                'text-color': '#d0e8ca',
                'button-color': '#6b8e23',
                'button-text-color': '#ffffff',
                'button-hover-color': '#8fbc5a',
                'board-color': '#4c6d4f',
                'scoreboard-text-color': '#d0e8ca',
                'skip-history-heading-color': '#d0e8ca',
                'skip-history-text-color': '#9ca3af',
                 'piece-black-dark': '#000',
                'piece-black-light': '#333',
                'piece-white-dark': '#c0d9bc',
                'piece-white-light': '#e0f9dc',
                 'last-move-dot-color': '#ff0000',
                 'timer-text-color': '#d0e8ca', /* Match forest text */
                 'timer-bg-color': 'rgba(0, 0, 0, 0.2)',
                 'timer-border-color': 'rgba(0, 0, 0, 0.3)',
                 'timer-low-color': '#ff0000' /* Maybe keep red regardless of theme */
            },
             grapefruit: {
                 'background-color-1': '#EC5564', 'background-color-2': '#D94452',
                 'text-color': '#ffffff', 'button-color': '#F76D82', 'button-text-color': '#1f2937',
                 'button-hover-color': '#FC8370', 'board-color': '#EC5564', 'scoreboard-text-color': '#ffffff',
                 'skip-history-heading-color': '#ffffff', 'skip-history-text-color': '#cccccc',
                 'piece-black-dark': '#000', 'piece-black-light': '#444', 'piece-white-dark': '#ddd', 'piece-white-light': '#fff',
                 'last-move-dot-color': '#ff0000',
                 'timer-text-color': '#ffffff', 'timer-bg-color': 'rgba(0,0,0,0.2)', 'timer-border-color': 'rgba(0,0,0,0.3)', 'timer-low-color': '#ff0000'
             },
             bittersweet: {
                 'background-color-1': '#FB6D51', 'background-color-2': '#E8563F',
                 'text-color': '#ffffff', 'button-color': '#FC8370', 'button-text-color': '#1f2937',
                 'button-hover-color': '#fb6d51', 'board-color': '#FB6D51', 'scoreboard-text-color': '#ffffff',
                 'skip-history-heading-color': '#ffffff', 'skip-history-text-color': '#cccccc',
                 'piece-black-dark': '#000', 'piece-black-light': '#444', 'piece-white-dark': '#ddd', 'piece-white-light': '#fff',
                 'last-move-dot-color': '#ff0000',
                 'timer-text-color': '#ffffff', 'timer-bg-color': 'rgba(0,0,0,0.2)', 'timer-border-color': 'rgba(0,0,0,0.3)', 'timer-low-color': '#ff0000'
             },
             sunflower: {
                 'background-color-1': '#FECD57', 'background-color-2': '#F5BA45',
                 'text-color': '#1f2937', 'button-color': '#FCD277', 'button-text-color': '#1f2937',
                 'button-hover-color': '#FECD57', 'board-color': '#FECD57', 'scoreboard-text-color': '#1f2937',
                 'skip-history-heading-color': '#1f2937', 'skip-history-text-color': '#444444',
                 'piece-black-dark': '#000', 'piece-black-light': '#444', 'piece-white-dark': '#ddd', 'piece-white-light': '#fff',
                 'last-move-dot-color': '#ff0000',
                 'timer-text-color': '#1f2937', 'timer-bg-color': 'rgba(255,255,255,0.3)', 'timer-border-color': 'rgba(255,255,255,0.4)', 'timer-low-color': '#ef4444'
             },
             grass: {
                 'background-color-1': '#9ED36A', 'background-color-2': '#8AC054',
                 'text-color': '#1f2937', 'button-color': '#84E080', 'button-text-color': '#1f2937',
                 'button-hover-color': '#62DDBD', 'board-color': '#9ED36A', 'scoreboard-text-color': '#1f2937',
                 'skip-history-heading-color': '#1f2937', 'skip-history-text-color': '#444444',
                 'piece-black-dark': '#000', 'piece-black-light': '#444', 'piece-white-dark': '#ddd', 'piece-white-light': '#fff',
                 'last-move-dot-color': '#ff0000',
                 'timer-text-color': '#1f2937', 'timer-bg-color': 'rgba(255,255,255,0.3)', 'timer-border-color': 'rgba(255,255,255,0.4)', 'timer-low-color': '#ef4444'
             },
             mint: {
                 'background-color-1': '#46CEAD', 'background-color-2': '#35BB9B',
                 'text-color': '#ffffff', 'button-color': '#62DDBD', 'button-text-color': '#1f2937',
                 'button-hover-color': '#84E080', 'board-color': '#46CEAD', 'scoreboard-text-color': '#ffffff',
                 'skip-history-heading-color': '#ffffff', 'skip-history-text-color': '#cccccc',
                 'piece-black-dark': '#000', 'piece-black-light': '#444', 'piece-white-dark': '#ddd', 'piece-white-light': '#fff',
                 'last-move-dot-color': '#ff0000',
                 'timer-text-color': '#ffffff', 'timer-bg-color': 'rgba(0,0,0,0.2)', 'timer-border-color': 'rgba(0,0,0,0.3)', 'timer-low-color': '#ff0000'
             },
             aqua: {
                 'background-color-1': '#5EC0C0', 'background-color-2': '#40A9A9',
                 'text-color': '#ffffff', 'button-color': '#7BC9C9', 'button-text-color': '#1f2937',
                 'button-hover-color': '#5a9ed0', 'board-color': '#5EC0C0', 'scoreboard-text-color': '#ffffff',
                 'skip-history-heading-color': '#ffffff', 'skip-history-text-color': '#cccccc',
                 'piece-black-dark': '#000', 'piece-black-light': '#444', 'piece-white-dark': '#ddd', 'piece-white-light': '#fff',
                 'last-move-dot-color': '#ff0000',
                 'timer-text-color': '#ffffff', 'timer-bg-color': 'rgba(0,0,0,0.2)', 'timer-border-color': 'rgba(0,0,0,0.3)', 'timer-low-color': '#ff0000'
             },
             bluejeans: {
                 'background-color-1': '#5E9CEA', 'background-color-2': '#4B89DA',
                 'text-color': '#ffffff', 'button-color': '#73B1F4', 'button-text-color': '#1f2937',
                 'button-hover-color': '#3282b8', 'board-color': '#5E9CEA', 'scoreboard-text-color': '#ffffff',
                 'skip-history-heading-color': '#ffffff', 'skip-history-text-color': '#cccccc',
                 'piece-black-dark': '#000', 'piece-black-light': '#444', 'piece-white-dark': '#ddd', 'piece-white-light': '#fff',
                 'last-move-dot-color': '#ff0000',
                 'timer-text-color': '#ffffff', 'timer-bg-color': 'rgba(0,0,0,0.2)', 'timer-border-color': 'rgba(0,0,0,0.3)', 'timer-low-color': '#ff0000'
             },
             lavenderpurple: {
                 'background-color-1': '#AC92EA', 'background-color-2': '#967ADA',
                 'text-color': '#1f2937', 'button-color': '#B3A5EF', 'button-text-color': '#1f2937',
                 'button-hover-color': '#F299CE', 'board-color': '#AC92EA', 'scoreboard-text-color': '#1f2937',
                 'skip-history-heading-color': '#1f2937', 'skip-history-text-color': '#444444',
                 'piece-black-dark': '#000', 'piece-black-light': '#444', 'piece-white-dark': '#ddd', 'piece-white-light': '#fff',
                 'last-move-dot-color': '#ff0000',
                 'timer-text-color': '#1f2937', 'timer-bg-color': 'rgba(255,255,255,0.3)', 'timer-border-color': 'rgba(255,255,255,0.4)', 'timer-low-color': '#ef4444'
             },
             lavenderpink: {
                 'background-color-1': '#EB87BF', 'background-color-2': '#D670AC',
                 'text-color': '#1f2937', 'button-color': '#F299CE', 'button-text-color': '#1f2937',
                 'button-hover-color': '#B3A5EF', 'board-color': '#EB87BF', 'scoreboard-text-color': '#1f2937',
                 'skip-history-heading-color': '#1f2937', 'skip-history-text-color': '#444444',
                 'piece-black-dark': '#000', 'piece-black-light': '#444', 'piece-white-dark': '#ddd', 'piece-white-light': '#fff',
                 'last-move-dot-color': '#ff0000',
                 'timer-text-color': '#1f2937', 'timer-bg-color': 'rgba(255,255,255,0.3)', 'timer-border-color': 'rgba(255,255,255,0.4)', 'timer-low-color': '#ef4444'
             },
             skintone: {
                 'background-color-1': '#F0C8A5', 'background-color-2': '#E4B693',
                 'text-color': '#1f2937', 'button-color': '#F4D0B5', 'button-text-color': '#1f2937',
                 'button-hover-color': '#FC8370', 'board-color': '#F0C8A5', 'scoreboard-text-color': '#1f2937',
                 'skip-history-heading-color': '#1f2937', 'skip-history-text-color': '#444444',
                 'piece-black-dark': '#000', 'piece-black-light': '#444', 'piece-white-dark': '#ddd', 'piece-white-light': '#fff',
                 'last-move-dot-color': '#ff0000',
                 'timer-text-color': '#1f2937', 'timer-bg-color': 'rgba(255,255,255,0.3)', 'timer-border-color': 'rgba(255,255,255,0.4)', 'timer-low-color': '#ef4444'
             },
             lightgray: {
                 'background-color-1': '#E5E8EC', 'background-color-2': '#CBD0D8',
                 'text-color': '#1f2937', 'button-color': '#F4F6F9', 'button-text-color': '#1f2937',
                 'button-hover-color': '#A9B1BC', 'board-color': '#E5E8EC', 'scoreboard-text-color': '#1f2937',
                 'skip-history-heading-color': '#1f2937', 'skip-history-text-color': '#444444',
                 'piece-black-dark': '#000', 'piece-black-light': '#444', 'piece-white-dark': '#ddd', 'piece-white-light': '#fff',
                 'last-move-dot-color': '#ff0000',
                 'timer-text-color': '#1f2937', 'timer-bg-color': 'rgba(255,255,255,0.3)', 'timer-border-color': 'rgba(255,255,255,0.4)', 'timer-low-color': '#ef4444'
             },
             darkgray: {
                 'background-color-1': '#646C77', 'background-color-2': '#424953',
                 'text-color': '#ffffff', 'button-color': '#A9B1BC', 'button-text-color': '#1f2937',
                 'button-hover-color': '#E5E8EC', 'board-color': '#646C77', 'scoreboard-text-color': '#ffffff',
                 'skip-history-heading-color': '#ffffff', 'skip-history-text-color': '#cccccc',
                 'piece-black-dark': '#000', 'piece-black-light': '#444', 'piece-white-dark': '#ddd', 'piece-white-light': '#fff',
                 'last-move-dot-color': '#ff0000',
                 'timer-text-color': '#ffffff', 'timer-bg-color': 'rgba(0,0,0,0.2)', 'timer-border-color': 'rgba(0,0,0,0.3)', 'timer-low-color': '#ff0000'
             }
        };
    // Load and apply theme from localStorage
    function applyTheme(themeName) {
        const theme = colorThemes[themeName];
        if (theme) {
            for (const [variable, value] of Object.entries(theme)) {
                document.documentElement.style.setProperty(`--${variable}`, value);
            }
        }
    }

    function loadTheme() {
        const theme = localStorage.getItem('color-theme') || 'default';
        applyTheme(theme);
    }

    loadTheme(); // Apply initial theme on load

    window.addEventListener('storage', function (event) {
        if (event.key === 'color-theme') {
            loadTheme();
        }
    });

    const placeSound = new Audio('sounds/place.mp3');
    const winSound = new Audio('sounds/win.wav');

    const BOARD_SIZE = 8;
    const EMPTY = 0, BLACK = 1, WHITE = 2;

    // Player Data - Will be populated from localStorage
    let player1 = { name: 'Black Player', color: BLACK };
    let player2 = { name: 'White Player', color: WHITE };

    let currentPlayer = BLACK; // Start with Player 1's color (determined by setup)
    let scores = {black: 2, white: 2};
    let showHints = true;
    let gameOver = false;
    let board;
    let animationInProgress = false;
    let cells = [];
    // skipHistory stores objects { message: string, class: string, playerColor: number }
    let skipHistory = [];
    // Game history stores the coordinates of the piece placed in that move AND the board state *after* the move
    // Each entry in gameHistory should correspond to one entry in skipHistory
    let gameHistory = []; // Each state will now include 'lastPlaced' piece coords
    let currentHistoryIndex = -1;
    let isViewingHistory = false;

     // Minimax depth for evaluation feedback (can be shallow, e.g., 1 or 2)
    const FEEDBACK_EVAL_DEPTH = 2;

    // Timer variables
    let timerInterval;
    let timeLeft;
    const MOVE_TIME_SECONDS = 30; // Time allowed per move
    let timerDisplayElement;


    const directions = [
        [-1, 0], [1, 0], [0, -1], [0, 1],
        [-1, -1], [-1, 1], [1, -1], [1, 1]
    ];

    // Define "bad" squares (C-squares) - adjacent to corners
    const cSquares = [
        [0, 1], [1, 0], [1, 1], // Top-left corner
        [0, 6], [1, 7], [1, 6], // Top-right corner
        [6, 0], [7, 1], [6, 1], // Bottom-left corner
        [6, 7], [7, 6], [6, 6]  // Bottom-right corner
    ];
    // Helper to check if a square is a C-square
    const isCSquare = (r, c) => cSquares.some(([cr, cc]) => cr === r && cc === c);
    // Helper to check if a square is a corner
     const isCorner = (r, c) => (r === 0 || r === 7) && (c === 0 || c === 7);


    let prevMoveBtn;
    let nextMoveBtn;
    let toggleHintsDropdownLink;
    let restartDropdownLink;
    let skipHistoryList;


    document.addEventListener('DOMContentLoaded', () => {
        const gameMenuButton = document.getElementById('game-menu-button');
        const gameMenuContent = document.getElementById('game-menu-content');
        const gameMenuDropdown = document.querySelector('.game-menu-dropdown');

        timerDisplayElement = document.getElementById('timer'); // Get timer element

        prevMoveBtn = document.getElementById('prev-move-btn');
        nextMoveBtn = document.getElementById('next-move-btn');
        toggleHintsDropdownLink = document.getElementById('toggle-hints-dropdown');
        restartDropdownLink = document.getElementById('restart-dropdown');
        skipHistoryList = document.getElementById('skip-history-list');


        if (gameMenuButton && gameMenuContent && gameMenuDropdown) {
            gameMenuButton.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent click from closing immediately
                const isActive = gameMenuDropdown.classList.toggle('active');
                gameMenuButton.setAttribute('aria-expanded', isActive ? 'true' : 'false');
            });

            // Close dropdown if clicking outside
            window.addEventListener('click', (event) => {
                if (gameMenuDropdown.classList.contains('active')) {
                    if (!gameMenuDropdown.contains(event.target)) {
                        gameMenuDropdown.classList.remove('active');
                        gameMenuButton.setAttribute('aria-expanded', 'false');
                    }
                }
            });

            gameMenuContent.addEventListener('click', () => {
                gameMenuDropdown.classList.remove('active');
                gameMenuButton.setAttribute('aria-expanded', 'false');
            });
        }

        if (toggleHintsDropdownLink) {
            toggleHintsDropdownLink.addEventListener('click', (e) => {
                e.preventDefault(); // Prevent default link behavior
                showHints = !showHints;
                 // Re-render to update hint visibility. Dot/history reads from history state.
                renderBoard([]);
                toggleHintsDropdownLink.textContent = showHints ? 'Hide Hints' : 'Show Hints'; // Update button text
            });
        }

        if (restartDropdownLink) {
            restartDropdownLink.addEventListener('click', (e) => {
                e.preventDefault(); // Prevent default link behavior
                 // Prevent restart if animating or viewing history
                if (animationInProgress || isViewingHistory) return;
                initializeGame(); // Start a new game
            });
        }

         // Add event listeners for history buttons
        if(prevMoveBtn) {
            prevMoveBtn.addEventListener('click', showPreviousMove);
        }
        if(nextMoveBtn) {
            nextMoveBtn.addEventListener('click', showNextMove);
        }

        // Initialize the game once the DOM is fully loaded
        initializeGame();
    });


     // --- Timer Logic ---
     function startTimer() {
        stopTimer(); // Stop any existing timer first
        timeLeft = MOVE_TIME_SECONDS;
        updateTimerDisplay();
        timerInterval = setInterval(updateTimer, 1000); // Update every second
     }

     function stopTimer() {
        clearInterval(timerInterval);
        timerInterval = null;
         if(timerDisplayElement) timerDisplayElement.classList.remove('low-time');
     }

     function updateTimer() {
        if (timeLeft > 0) {
            timeLeft--;
            updateTimerDisplay();
            if (timeLeft <= 5) { // Highlight when time is low
                timerDisplayElement.classList.add('low-time');
            }
        } else {
            // Timer ran out
            stopTimer();
            handleTimerEnd(); // Call function to handle timeout
        }
     }

     function updateTimerDisplay() {
        if(timerDisplayElement) {
             const minutes = Math.floor(timeLeft / 60);
             const seconds = timeLeft % 60;
             const formattedTime = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
             timerDisplayElement.textContent = formattedTime;
        }
     }

     async function handleTimerEnd() {
        if (gameOver || animationInProgress || isViewingHistory) return;

        animationInProgress = true; // Prevent further interaction during skip

        // Determine which player is skipping based on currentPlayer *before* switching
        const playerSkipping = (currentPlayer === player1.color) ? player1 : player2;

        // Add timeout message to history display *before* animation
        const timeoutMessage = `${playerSkipping.name}'s time ran out!`;
        const timeoutClass = 'skip-message timed-out'; // Add a class for timed out skips
        const timedOutPlayerColor = currentPlayer; // Store the color of the player who timed out
        // Message will be added to skipHistory when addHistoryEntry is called after animation


        await showSkipAnimation(playerSkipping.name); // Use the timed out player's name

        stopTimer(); // Stop timer again just to be safe after animation promise resolves

        // Switch player AFTER animation
        switchPlayer(); // Switch currentPlayer
        updatePlayerDisplay();

        // Add the timeout entry to history
        addHistoryEntry(null, timeoutMessage, timeoutClass, timedOutPlayerColor);


        const gameEndedAfterSkip = checkGameOver(); // Check game over state after skipping

        // Render board for the next player's turn
        renderBoard([]);


        animationInProgress = false; // Re-enable interaction

        if (gameEndedAfterSkip) return;

         if (!isViewingHistory) { // Only check if not viewing history
             setTimeout(async () => {
                 if (!gameOver && !isViewingHistory && !animationInProgress) {
                      await checkForAutoSkip(); // checkForAutoSkip starts timer for the next player
                 }
             }, 50);
        }
     }

     // --- End Timer Logic ---


     // Function to load player names and colors from localStorage
     function loadPlayerSetup() {
         const setupData = localStorage.getItem('othelloPlayerSetup');
         if (setupData) {
             const data = JSON.parse(setupData);
             player1 = {
                 name: data.player1Name,
                 color: data.player1Color === 'black' ? BLACK : WHITE
             };
             player2 = {
                 name: data.player2Name,
                 color: data.player2Color === 'black' ? BLACK : WHITE
             };
              // Clear the data from localStorage after reading it (optional, but keeps it clean)
              // localStorage.removeItem('othelloPlayerSetup');
         } else {
              // Default setup if no data is found (e.g., direct navigation)
             player1 = { name: 'Black Player', color: BLACK };
             player2 = { name: 'White Player', color: WHITE };
         }
         // Set the initial currentPlayer based on player1's chosen color
         currentPlayer = player1.color;
     }


    function initializeBoard() {
        const newBoard = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
        // Initial pieces always start Black on left-bottom, White on right-top of the center squares
        newBoard[3][3] = WHITE;
        newBoard[3][4] = BLACK;
        newBoard[4][3] = BLACK;
        newBoard[4][4] = WHITE;
        return newBoard;
    }

    function copyBoard(currentBoard) {
         if (!currentBoard) return null;
         return currentBoard.map(row => [...row]);
    }

    // --- History / State Management ---

    // Adds a state and its corresponding message to history
    // Handles truncation if we're not at the latest state
    function addHistoryEntry(lastPlacedCoords, message, className = '', playerColor = null) {
        // If we were viewing history, truncate future states and messages
        if (currentHistoryIndex < gameHistory.length - 1) {
            gameHistory = gameHistory.slice(0, currentHistoryIndex + 1);
            skipHistory = skipHistory.slice(0, currentHistoryIndex + 1); // Truncate messages too
            isViewingHistory = false; // Ensure history view is off
        }

        // Add the message for the move/skip that just happened
         // playerColor is the color of the player who just completed their turn (or skipped)
        skipHistory.push({ message: message, class: className, playerColor: playerColor });

         // Store the board *after* the pieces have been updated (this state corresponds to the message added above)
        const currentState = {
            board: copyBoard(board), // Capture the board state *after* the move/flip
            scores: { ...scores },
            currentPlayer: currentPlayer, // Store the *next* player (whose turn is after this state)
            lastPlaced: lastPlacedCoords // Store the coordinates of the piece placed in the completed move (null for init/skips)
        };
        gameHistory.push(currentState);

        // Update index to the new latest state
        currentHistoryIndex = gameHistory.length - 1;

        // Update the display after adding the new entry
        updateSkipHistoryDisplay();
        updateHistoryButtonStates();
    }


    // applyGameState uses the stored state information to render the board and update UI
    function applyGameState(state) {
        stopTimer(); // Stop timer when viewing history

        // Restore board and scores to the historical state
        board = copyBoard(state.board);
        scores = { ...state.scores };
        // Restore whose turn it was *after* this state was reached
        currentPlayer = state.currentPlayer;

        // Update UI elements based on the restored state
        updateScores(board);
        updatePlayerDisplay();
         updateTimerDisplay(); // Reset timer display (will show '--' in history view)


        // Re-render board based on the historical state. Pass empty array for animation.
        // renderBoard now reads lastPlaced from gameHistory[currentHistoryIndex].
        renderBoard([]);

        // Update skip history display to show the history view message or correct messages
        updateSkipHistoryDisplay();
        updateHistoryButtonStates(); // Update button state after applying
    }

    function updateHistoryButtonStates() {
        if (!prevMoveBtn || !nextMoveBtn) return;

        prevMoveBtn.disabled = currentHistoryIndex <= 0;
        nextMoveBtn.disabled = currentHistoryIndex >= gameHistory.length - 1;

        isViewingHistory = currentHistoryIndex < gameHistory.length - 1;

        const boardElement = document.getElementById('board');
        if (boardElement) {
            boardElement.classList.toggle('history-view', isViewingHistory);
        }

        // Hide timer when viewing history
         if(timerDisplayElement) {
             timerDisplayElement.style.display = isViewingHistory ? 'none' : '';
             if(isViewingHistory) stopTimer(); // Ensure timer is stopped
         }
    }

    function showPreviousMove() {
         if (animationInProgress || currentHistoryIndex <= 0) return;

        currentHistoryIndex--;
        applyGameState(gameHistory[currentHistoryIndex]);
    }

    async function showNextMove() {
         if (animationInProgress || currentHistoryIndex >= gameHistory.length - 1) return;

        currentHistoryIndex++;
        applyGameState(gameHistory[currentHistoryIndex]);

        // If we return to the latest state (isViewingHistory becomes false), check for auto-skip
        if (!isViewingHistory && !gameOver) {
             // Add a small delay before checking for auto-skip to allow the board/feedback to render
            setTimeout(async () => {
                // Check again if state is still valid to proceed
                if (!gameOver && !isViewingHistory && !animationInProgress) {
                   await checkForAutoSkip(); // checkForAutoSkip starts the timer if moves are available
                }
            }, 100); // Short delay (milliseconds)
        }
    }

    // --- End History / State Management ---


    function isValidMove(row, col, player) {
         if (isViewingHistory) return false; // Cannot move in history view

        if (!board || row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE || board[row][col] !== EMPTY) {
             return false;
        }

        for (let [dx, dy] of directions) {
            let x = row + dx, y = col + dy, foundOpponent = false;
            while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {
                if (board[x][y] === EMPTY) break;
                if (board[x][y] === player) {
                    if (foundOpponent) return true;
                    else break;
                }
                if (board[x][y] === (player === BLACK ? WHITE : BLACK)) { // Check for opponent's color explicitly
                    foundOpponent = true;
                } else {
                     break; // Found something other than current player, opponent, or empty (shouldn't happen but safe)
                }
                x += dx;
                y += dy;
            }
        }
        return false;
    }

     // getValidMoves also calculates flip counts for evaluation purposes
    function getValidMoves(player, currentBoard = board) {
        if (isViewingHistory && currentBoard === board) return []; // Only restrict if on the main board and viewing history

        const validMoves = [];
        if (!currentBoard) return validMoves;

        currentBoard.forEach((row, rowIndex) =>
            row.forEach((_, colIndex) => {
                if (currentBoard[rowIndex][colIndex] === EMPTY) {
                     const flips = getFlipCount(rowIndex, colIndex, player, currentBoard);
                     if (flips > 0) {
                          // Store move as [row, col, flipCount]
                          validMoves.push([rowIndex, colIndex, flips]);
                     }
                }
            })
        );
        return validMoves; // Returns moves as [row, col, flipCount]
    }

     // Helper to get the number of pieces flipped by a potential move
    function getFlipCount(row, col, player, currentBoard) {
        if (!currentBoard || row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE || currentBoard[row][col] !== EMPTY) {
             return 0; // Must be an empty cell within bounds
        }

        let flipCount = 0;
        const opponent = (player === BLACK) ? WHITE : BLACK;

        directions.forEach(([dx, dy]) => {
            let x = row + dx, y = col + dy;
            let piecesToFlipInDirection = 0;
            while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {
                if (currentBoard[x][y] === EMPTY) break;
                if (currentBoard[x][y] === player) {
                    if (piecesToFlipInDirection > 0) { // Found player's piece after opponent's
                        flipCount += piecesToFlipInDirection; // Add collected flips in this direction
                    }
                    break; // Stop searching in this direction
                }
                if (currentBoard[x][y] === opponent) {
                    piecesToFlipInDirection++;
                } else {
                    break; // Found something unexpected (like another empty cell)
                }
                x += dx;
                y += dy;
            }
        });
        return flipCount;
    }


     // flipPieces returns the pieces that were flipped *and* the one placed
     // It also accepts a board state to operate on (for evaluation)
    function flipPieces(row, col, player, currentBoard) {
        // Create a deep copy if not modifying the live board
        const boardToModify = (currentBoard === board) ? board : copyBoard(currentBoard);

        // Must place the piece first
        if (boardToModify[row][col] !== EMPTY) {
             console.error("flipPieces called on non-empty cell", {row: row, col: col, player: player, boardState: copyBoard(boardToModify)});
             // In case of error, return original board state or copy without changes
             return {newBoard: currentBoard === board ? board : copyBoard(currentBoard), flippedPieces: [], placedPiece: null};
        }
        boardToModify[row][col] = player; // Place the new piece

        const placedPiece = {x: row, y: col}; // The piece that was just placed

        const flippedPieces = []; // Only store pieces that were *flipped* here for the animation logic

        const opponent = (player === BLACK) ? WHITE : BLACK;

        directions.forEach(([dx, dy]) => {
            let x = row + dx, y = col + dy;
            const piecesToFlipInDirection = [];
            while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {
                if (boardToModify[x][y] === EMPTY) break;
                if (boardToModify[x][y] === player) {
                    if (piecesToFlipInDirection.length > 0) {
                        // Found a sequence of opponent pieces ending in player's piece
                        piecesToFlipInDirection.forEach(([fx, fy]) => {
                            boardToModify[fx][fy] = player;
                            // Only add to flippedPieces list if we are flipping the *actual* game board
                             if (currentBoard === board) { // Check if operating on the main game board
                                flippedPieces.push({x: fx, y: fy, original: opponent, new: player});
                             }
                        });
                    }
                    break; // Stop searching in this direction
                }
                if (boardToModify[x][y] === opponent) {
                    piecesToFlipInDirection.push([x, y]);
                } else {
                    break; // Found something unexpected (like another empty cell)
                }
                x += dx;
                y += dy;
            }
        });
        // Return flipped pieces for animation (only if operating on the live board),
        // the resulting board state, and the placed piece coords for dot/history.
         const finalBoardState = (currentBoard === board) ? board : boardToModify; // Return the modified copy or the original board
        return {newBoard: finalBoardState, flippedPieces, placedPiece};
    }


    function updateScores(currentBoard) {
        let blackCount = 0, whiteCount = 0;
        if (!currentBoard) return;
        currentBoard.forEach(row => row.forEach(cell => {
            if (cell === BLACK) blackCount++;
            if (cell === WHITE) whiteCount++;
        }));
        scores = {black: blackCount, white: whiteCount};

        // Use player names based on their color
        const blackPlayerName = player1.color === BLACK ? player1.name : player2.name;
        const whitePlayerName = player1.color === WHITE ? player1.name : player2.name;

        document.getElementById('black-score').textContent = `${blackPlayerName} : ${scores.black}`;
        document.getElementById('white-score').textContent = `${whitePlayerName} : ${scores.white}`;
    }

    function updatePlayerDisplay() {
        const blackScoreDiv = document.getElementById('black-score');
        const whiteScoreDiv = document.getElementById('white-score');

        blackScoreDiv.classList.remove('current-player', 'black-turn-active');
        whiteScoreDiv.classList.remove('current-player', 'white-turn-active');

        if (!isViewingHistory && !gameOver) { // Only show active player indicator during a live game
             // Determine which score div corresponds to the current player
             const currentPlayerColor = currentPlayer; // This is BLACK or WHITE

             if (player1.color === currentPlayerColor) {
                 const scoreDiv = (currentPlayerColor === BLACK) ? blackScoreDiv : whiteScoreDiv;
                 scoreDiv.classList.add('current-player', currentPlayerColor === BLACK ? 'black-turn-active' : 'white-turn-active');
             } else if (player2.color === currentPlayerColor){ // Must be player2
                 const scoreDiv = (currentPlayerColor === BLACK) ? blackScoreDiv : whiteScoreDiv;
                  scoreDiv.classList.add('current-player', currentPlayerColor === BLACK ? 'black-turn-active' : 'white-turn-active');
             }
        }
    }

    function checkGameOver() {
        // Only check game over on the live board and when not viewing history
        if (isViewingHistory && !gameOver) return false;
        // If we are currently viewing history and gameOver is true, keep it true
        if (gameOver && isViewingHistory) return true;


        const blackMoves = getValidMoves(BLACK); // Moves with flip counts
        const whiteMoves = getValidMoves(WHITE); // Moves with flip counts

        if (blackMoves.length === 0 && whiteMoves.length === 0) {
            // Game is newly over
            gameOver = true;
            winSound.play();

             const blackScore = scores.black;
             const whiteScore = scores.white;

             const blackPlayerName = player1.color === BLACK ? player1.name : player2.name;
             const whitePlayerName = player1.color === WHITE ? player1.name : player2.name;

             let winnerMessage;
             if (blackScore > whiteScore) {
                 winnerMessage = `${blackPlayerName} Wins!`;
             } else if (whiteScore > blackScore) {
                 winnerMessage = `${whitePlayerName} Wins!`;
             } else {
                 winnerMessage = 'It\'s a Tie!';
             }

            document.getElementById('game-over').innerHTML = `
                <div class="game-over">Game Over! ${winnerMessage}</div>`;

             // Add Game Over message to history *before* capturing the final state IF it's not already the last message
             // The state for Game Over is the *last* state captured by handleMove or autoSkipTurn.
             if (!skipHistory.length || (skipHistory[skipHistory.length - 1] && skipHistory[skipHistory.length - 1].message !== "Game Over!")) {
                  // Note: This message doesn't correspond to a board state *change*,
                  // but represents the conclusion after the last state.
                  // We add it directly to skipHistory display logic now.
                  skipHistory.push({ message: "Game Over!", class: 'system-message', playerColor: null });
                  updateSkipHistoryDisplay(); // Update display after adding the message
             } else {
                 // If Game Over message was already the last one (e.g., restarted after game over), just update history buttons/display
                 updateSkipHistoryDisplay();
                 updateHistoryButtonStates();
             }

            stopTimer(); // Stop timer when game is over

            return true; // Game is over
        }

         // If game was over but now there are valid moves (e.g., after history navigation back to a non-game-over state)
        if(gameOver && !isViewingHistory && (blackMoves.length > 0 || whiteMoves.length > 0)) {
             gameOver = false;
             document.getElementById('game-over').innerHTML = '';
             // The check for auto-skip after history navigation will re-trigger the game flow
        }
        return false; // Game is not over
    }

     // Helper function to check game over state on a given board (for minimax evaluation)
    function isGameOver(currentBoard) {
        // Check if either player has moves on this specific board state
        const blackMoves = getValidMoves(BLACK, currentBoard); // getValidMoves returns moves with flip counts now
        const whiteMoves = getValidMoves(WHITE, currentBoard);
        return blackMoves.length === 0 && whiteMoves.length === 0;
    }


    function areBoardsEqual(board1, board2) {
        if (!board1 || !board2 || board1.length !== board2.length || board1[0].length !== board2[0].length) return false;
        for(let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                if (board1[i][j] !== board2[i][j]) return false;
            }
        }
        return true;
    }


     // renderBoard accepts piecesToAnimate (for flip animation) and gets lastPlacedCoords/feedback from history for dot/message
     // It now needs to know which player's turn it is in the *currently displayed history state* to correctly show hints
    function renderBoard(piecesToAnimate = []) {
        // Check for critical elements before rendering
        if (!board || cells.length === 0 || currentHistoryIndex < 0 || !gameHistory[currentHistoryIndex]) {
             // This might happen during initialization before the first state is added
             // console.warn("Render skipped: Missing board, cells, or initial history state.");
            return;
        }

         // Get the player whose turn it is in the *current* history state being viewed/displayed
         // This is the player who is *about to* move in this state.
        const stateBeingViewed = gameHistory[currentHistoryIndex];
        const playerForHints = stateBeingViewed.currentPlayer; // Use the player stored in the historical state
        const validMoves = (!isViewingHistory && showHints && !gameOver) ? getValidMoves(playerForHints) : []; // Hints only on the current live board state for the actual current player
        const playerForHintsColorName = playerForHints === BLACK ? 'black' : 'white';


         // Get the lastPlaced coords from the *current* history state for the dot
         // This is the piece placed that resulted in the *previous* state
        const stateLastPlaced = stateBeingViewed.lastPlaced;
        // Check if the piece at [r, c] is the last placed piece for the *current* history state
        const isLastPlaced = (r, c) =>
             stateLastPlaced && stateLastPlaced.x === r && stateLastPlaced.y === c;


        board.forEach((row, rowIndex) => {
            row.forEach((cell, colIndex) => {
                const cellElement = cells[rowIndex][colIndex];
                if (!cellElement) return;

                // --- Update Hints ---
                const isHint = validMoves.some(([x, y]) => x === rowIndex && y === colIndex);
                cellElement.classList.toggle('hint', isHint);
                if (isHint) {
                     // Use the color of the player whose turn it is for hints
                     cellElement.dataset.player = playerForHintsColorName;
                     // Only allow pointer cursor on the live board when not animating and it's the playerForHints' turn
                     // which means it must be the currentPlayer's turn, and not history view
                     cellElement.style.cursor = (!isViewingHistory && !animationInProgress && playerForHints === currentPlayer) ? 'pointer' : 'default';
                } else {
                    delete cellElement.dataset.player;
                    // Set cursor based on whether we are viewing history or it's game over/animating
                     cellElement.style.cursor = (isViewingHistory || gameOver || animationInProgress || playerForHints !== currentPlayer) ? 'default' : 'pointer';
                }


                // --- Update Piece ---
                let piece = cellElement.querySelector('.piece');
                const targetPieceColor = cell; // cell contains BLACK, WHITE, or EMPTY
                const targetPieceColorName = targetPieceColor === BLACK ? 'black' : (targetPieceColor === WHITE ? 'white' : null);


                if (targetPieceColor !== EMPTY) {
                    // This cell should have a piece
                    if (!piece) {
                        // No piece exists, create a new one with both faces
                        piece = document.createElement('div');
                        piece.className = 'piece';
                        const blackFace = document.createElement('div');
                        blackFace.className = 'piece-face black';
                        const whiteFace = document.createElement('div');
                        whiteFace.className = 'piece-face white';
                        piece.appendChild(blackFace);
                        piece.appendChild(whiteFace);
                        cellElement.appendChild(piece);

                        // Set the initial color class instantly (no animation on creation)
                        piece.classList.add(`color-${targetPieceColorName}`);

                    } else {
                         // Piece exists, check if its color needs updating
                         const currentPieceColorName = piece.classList.contains('color-black') ? 'black' : (piece.classList.contains('color-white') ? 'white' : null);

                         if (currentPieceColorName !== targetPieceColorName) {
                             // The piece's visual color is different from what the board state says it should be

                             // Determine if this piece should *animate* based on the piecesToAnimate list passed to this render call.
                             // piecesToAnimate contains ONLY the pieces that flipped in the latest move.
                             const shouldAnimate = piecesToAnimate.some(p => p.x === rowIndex && p.y === colIndex && p.new === targetPieceColor && p.original !== EMPTY); // Only trigger animation for actual flips

                              if (shouldAnimate && !isViewingHistory && animationInProgress) { // Trigger animation only during a live, non-history, animation-in-progress frame
                                 // Trigger the CSS transition by changing the class.
                                 if (currentPieceColorName) piece.classList.remove(`color-${currentPieceColorName}`);
                                 piece.classList.add(`color-${targetPieceColorName}`);
                              } else {
                                  // No animation needed (history view, initial render, or a placed piece that didn't flip)
                                  // Just set the final color instantly
                                  if (currentPieceColorName) piece.classList.remove(`color-${currentPieceColorName}`);
                                  piece.classList.add(`color-${targetPieceColorName}`);
                              }
                         }
                    }

                    // --- Update Last Move Dot ---
                    // Add/remove the 'last-move-piece' class based on the lastPlaced info from the *current* history state
                    piece.classList.toggle('last-move-piece', isLastPlaced(rowIndex, colIndex));

                } else {
                    // This cell should be empty
                    if (piece) {
                        piece.remove();
                    }
                    cellElement.classList.remove('last-move-cell-hint'); // Ensure hint styles are cleared if empty
                }

                 // Add corner dot class if applicable (PvPL always has these)
                 if(isCorner(rowIndex, colIndex)) {
                     cellElement.classList.add('corner-dot');
                 } else {
                      cellElement.classList.remove('corner-dot'); // Remove if no longer a corner (e.g., on a non-board element) - unlikely here but safe
                 }
            });
        });
    }


    function switchPlayer() {
         // Switch the internal currentPlayer constant
        currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
         // The actual player object (player1/player2) whose turn it is
         // is derived in updatePlayerDisplay, addHistoryEntry etc. by checking their .color property.
    }

    // Add a message/item to the skip history display
    // This function is now only responsible for rendering, not adding messages.
    function updateSkipHistoryDisplay() {
        if (!skipHistoryList) return;
        skipHistoryList.innerHTML = ''; // Clear existing entries

        if (isViewingHistory) {
             // Show a placeholder message when viewing history
             const messageItem = document.createElement('li');
             messageItem.textContent = "(Viewing historical state)";
             messageItem.classList.add('history-view-message');
             skipHistoryList.appendChild(messageItem);

             // In history view, we display messages up to the *current* state from the one shown on the board
             const displayHistory = skipHistory.slice(0, currentHistoryIndex + 1);

             displayHistory.forEach(item => {
                // Don't display the history-view-message placeholder itself here
                 if (item.class.includes('history-view-message')) return;

                const listItem = document.createElement('li');
                listItem.textContent = item.message;

                 // Add classes: base class, feedback class, and player color class
                 const classesToAdd = item.class.split(' ').filter(c => c); // Split and filter empty strings

                 if (item.playerColor === BLACK) {
                     classesToAdd.push('player-black');
                 } else if (item.playerColor === WHITE) {
                     classesToAdd.push('player-white');
                 } else {
                     classesToAdd.push('system-message'); // Add a class for non-player messages (Game Start, Game Over)
                 }

                 if (classesToAdd.length > 0) {
                    listItem.classList.add(...classesToAdd);
                 }

                skipHistoryList.appendChild(listItem);
             });


        } else {
             // Display the actual collected history messages when at the latest state
             // Ensure skipHistory and gameHistory are aligned (should be 1 message per state)
             // Display all messages currently in skipHistory, which should match gameHistory.length
             skipHistory.forEach(item => {
                const listItem = document.createElement('li');
                listItem.textContent = item.message;

                 // Add classes: base class, feedback class, and player color class
                 const classesToAdd = item.class.split(' ').filter(c => c); // Split and filter empty strings

                 if (item.playerColor === BLACK) {
                     classesToAdd.push('player-black');
                 } else if (item.playerColor === WHITE) {
                     classesToAdd.push('player-white');
                 } else {
                     classesToAdd.push('system-message'); // Add a class for non-player messages (Game Start, Game Over)
                 }

                 if (classesToAdd.length > 0) {
                    listItem.classList.add(...classesToAdd);
                 }

                skipHistoryList.appendChild(listItem);
             });
             // Scroll to the bottom to show the latest message
             skipHistoryList.scrollTop = skipHistoryList.scrollHeight;
        }
    }

    // Modified to accept player name for the popup
    function showSkipAnimation(playerName) {
        const overlay = document.getElementById('skip-turn-overlay');
        const playerMessageSpan = document.getElementById('skip-player-message');

        playerMessageSpan.textContent = playerName; // Use the actual player name
        overlay.classList.add('visible');

        return new Promise(resolve => {
            setTimeout(() => {
                overlay.classList.remove('visible');
                setTimeout(resolve, 300); // Wait briefly for fade-out transition
            }, 1500); // Popup visible duration
        });
    }


    async function autoSkipTurn() {
        if (gameOver || isViewingHistory || animationInProgress) return;

        animationInProgress = true; // Block interaction

        // Determine which player is skipping based on currentPlayer *before* switching
        const playerSkipping = (currentPlayer === player1.color) ? player1 : player2;

        // Add skip message to history display *before* animation, using the new entry system
        const skipMessage = `${playerSkipping.name} had no valid moves!`;
        const skipClass = 'skip-message';
        const skipPlayerColor = currentPlayer; // Store the color of the player who skipped
        // Message will be added to skipHistory when addHistoryEntry is called after animation


        await showSkipAnimation(playerSkipping.name);

        stopTimer(); // Stop timer on skip

        // Switch player AFTER animation
        switchPlayer(); // Switch currentPlayer
        updatePlayerDisplay();

        // Add the skip entry to history
        addHistoryEntry(null, skipMessage, skipClass, skipPlayerColor);


        const gameEndedAfterSkip = checkGameOver(); // Check game over state after skipping

        // Render board for the next player's turn
        renderBoard([]);


        animationInProgress = false; // Re-enable interaction

        if (gameEndedAfterSkip) return;

         if (!isViewingHistory) { // Only check if not viewing history
             setTimeout(async () => {
                 if (!gameOver && !isViewingHistory && !animationInProgress) {
                      await checkForAutoSkip(); // checkForAutoSkip starts timer for the next player
                 }
             }, 50);
        }
    }


    async function checkForAutoSkip() {
        if (gameOver || isViewingHistory || animationInProgress) return false;

        const validMoves = getValidMoves(currentPlayer); // Moves with flip counts

        if (validMoves.length === 0) {
             if (checkGameOver()) {
                 return false; // Game over state handled by checkGameOver, no skip animation/feedback needed here
             } else {
                 await autoSkipTurn(); // autoSkipTurn handles its own history entry and render
                 return true; // Player skipped
             }
        } else {
            // If there are valid moves, render the board to show potential hints.
            // Pass empty array for animation pieces. renderBoard reads history for dot.
            // This render is important to show/hide hints for the current player.
            renderBoard([]);
            startTimer(); // Start the timer for the current player
            return false; // No skip needed yet
        }
    }


    // --- Evaluation Logic (Minimax structure, simple evaluation) ---

    // Evaluate board from the perspective of 'player'
    // Returns score difference (player's score - opponent's score) + corner bonus + C-square penalty
    function evaluateBoard(currentBoard, player) {
        let playerScore = 0;
        let opponentScore = 0;
        const opponent = (player === BLACK) ? WHITE : BLACK;

        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                if (currentBoard[i][j] === player) {
                    playerScore++;
                } else if (currentBoard[i][j] === opponent) {
                    opponentScore++;
                }
            }
        }

        // Corner Bonus (Corners are very strategic)
        const corners = [[0, 0], [0, 7], [7, 0], [7, 7]];
        corners.forEach(([r, c]) => {
            if (currentBoard[r][c] === player) playerScore += 25; // Large bonus for corners (Adjusted slightly)
            else if (currentBoard[r][c] === opponent) opponentScore -= 25; // Large penalty if opponent has corners
        });

         // C-square penalty (Placing next to an empty corner is often bad)
         cSquares.forEach(([r, c]) => {
             // Check if it's a C-square *and* the adjacent corner is empty
             const cornerR = (r === 1 || r === 6) ? (r === 1 ? 0 : 7) : r;
             const cornerC = (c === 1 || c === 6) ? (c === 1 ? 0 : 7) : c;

              // Only apply penalty if the corner is currently empty on this board state
              if (currentBoard[r][c] === player && currentBoard[cornerR][cornerC] === EMPTY) {
                   // You placed on a C-square next to an empty corner - BAD
                  playerScore -= 15; // Significant penalty
              } else if (currentBoard[r][c] === opponent && currentBoard[cornerR][cornerC] === EMPTY) {
                   // Opponent placed on a C-square next to an empty corner - GOOD for you
                   opponentScore -= 15; // Equivalent bonus
              }
         });


        return playerScore - opponentScore; // Return the score difference from the perspective of 'player'
    }

    // Simplified Minimax function used ONLY for evaluating move quality for feedback.
    // It predicts future board states and their values (from the perspective of the player
    // who would move in that future state) up to FEEDBACK_EVAL_DEPTH.
    // This version uses the Negamax principle, consistently maximizing the value from the 'player' argument's perspective.
    function minimaxNegamax(currentBoard, depth, player, alpha, beta) {
         // player is the player whose turn it is *in this node*
        const opponent = (player === BLACK) ? WHITE : BLACK;

        // Base cases
        if (depth === 0 || isGameOver(currentBoard)) {
            // Return evaluation from the perspective of the player whose turn it is in this node
            // This is the standard Negamax base case. The perspective is handled by the negation in the recursive step.
             return evaluateBoard(currentBoard, player);
        }

        const validMoves = getValidMoves(player, copyBoard(currentBoard)).map(move => [move[0], move[1]]); // Get just coords

        // Handle skipping turns
        if (validMoves.length === 0) {
             // If the game is over after this skip, return the evaluation from the perspective of the player who just skipped.
             // This value will be negated by the parent node, which represents the opponent's turn.
             if (isGameOver(currentBoard)) {
                  return evaluateBoard(currentBoard, player);
             } else {
                  // Skip: recurse for opponent, keep depth, negate score
                  return -minimaxNegamax(currentBoard, depth - 1, opponent, -beta, -alpha); // Negate alpha/beta
             }
        }

        let maxEval = -Infinity; // This player wants to maximize their score (relative to opponent)
        for (const [r, c] of validMoves) {
            const { newBoard } = flipPieces(r, c, player, copyBoard(currentBoard));
            // Recurse for opponent, depth-1, negate alpha/beta, negate result
            // The recursive call calculates the *opponent's* maximum score difference from their perspective in the next turn.
            // Negating this gives the *current* player's score difference decrease (or opponent's gain).
            const evaluation = -minimaxNegamax(newBoard, depth - 1, opponent, -beta, -alpha);

            maxEval = Math.max(maxEval, evaluation);
            alpha = Math.max(alpha, evaluation);
            if (beta <= alpha) break; // Alpha-beta cut-off
        }

        return maxEval; // Return the best value found from *this player's* perspective
    }


    // --- Move Evaluation Feedback Logic ---

    // Helper to evaluate a specific move relative to the best possible move for feedback
    // Returns a feedback message and a CSS class
    // allPossibleMovesWithEvaluations is an array of { move: [r, c], value: number } for the player whose turn it was,
    // where 'value' is the evaluation of the *resulting* state from *that player's perspective*
    function getFeedback(chosenMoveCoords, allPossibleMovesWithEvaluations, playerColor) {
        const [chosenR, chosenC] = chosenMoveCoords;
        const playerMakingMove = (player1.color === playerColor) ? player1 : player2;
        const playerName = playerMakingMove.name;
        const opponentColor = (playerColor === BLACK) ? WHITE : BLACK;


        if (!allPossibleMovesWithEvaluations || allPossibleMovesWithEvaluations.length === 0) {
             return { message: `${playerName} made a move.`, className: '', playerColor: playerColor };
        }

        // Find the maximum possible value the player *could* have achieved with a valid move
         let maxPossibleValue = -Infinity;
         if (allPossibleMovesWithEvaluations.length > 0) {
             // The values stored are from the perspective of the player who just moved (via evaluateBoard or the Negamax result).
             // So, the player wants to maximize this value.
             maxPossibleValue = Math.max(...allPossibleMovesWithEvaluations.map(m => m.value));
         } else {
              return { message: `${playerName} made a move.`, className: '', playerColor: playerColor };
         }


        // Find the value of the specific move chosen
        const chosenMoveEntry = allPossibleMovesWithEvaluations.find(m => m.move[0] === chosenR && m.move[1] === chosenC);
        const chosenMoveValue = chosenMoveEntry ? chosenMoveEntry.value : null;

        if (chosenMoveValue === null) {
             return { message: `${playerName} made a move. (Eval Error)`, className: '', playerColor: playerColor };
        }

        // Calculate how much worse the chosen move's value is compared to the best possible value
        // value is from the perspective of playerColor. A higher value is better for playerColor.
        const valueDifference = maxPossibleValue - chosenMoveValue; // How much less is the chosen move than the best? A positive difference is bad.

        // Define thresholds for feedback (these might need tuning based on heuristic)
        const thresholds = {
             optimal: 0,     // Exactly the best move (difference <= 0)
             good: 5,       // Within 5 points of the best (difference <= 5)
             okay: 15       // Within 15 points of the best (difference <= 15)
             // Anything worse is 'Suboptimal'
        };

         // Add coordinates for clarity in history
         const coordsString = ` (${String.fromCharCode(65 + chosenC)}${chosenR + 1})`;


        // Specific checks first (can override value-based feedback if they are strong indicators)
         if (isCorner(chosenR, chosenC)) {
              // If it's a corner, it's generally a great move.
              // If its value is very close to the theoretical max, call it Optimal.
               if (valueDifference <= thresholds.good) { // Within 'good' threshold of the overall best by evaluator
                   return { message: `${playerName} took a Corner! Super Move!${coordsString}`, className: 'feedback-optimal', playerColor: playerColor };
              } else {
                   // A corner move that is still significantly worse than the overall best by the evaluator.
                  return { message: `${playerName} took a Corner${coordsString}, but be careful!`, className: 'feedback-risky', playerColor: playerColor };
              }
         }

        // Check for notoriously bad moves (C-squares)
         if (isCSquare(chosenR, chosenC)) {
              // Check if placing here allows the opponent to take a corner on their *next* turn
               const boardAfterChosenMove = flipPieces(chosenR, chosenC, playerColor, copyBoard(board)).newBoard;
               const opponentNextMoves = getValidMoves(opponentColor, boardAfterChosenMove);
               let opponentCanTakeCorner = false;
               const corners = [[0, 0], [0, 7], [7, 0], [7, 7]];
               for(const [or, oc] of opponentNextMoves) {
                    if(isCorner(or, oc)) {
                         opponentCanTakeCorner = true;
                         break;
                    }
               }
               if (opponentCanTakeCorner) {
                    return { message: `${playerName} played a Risky Move${coordsString} - might give opponent a corner!`, className: 'feedback-risky', playerColor: playerColor };
               }
              // If it's a C-square but doesn't immediately lose a corner, still might be suboptimal based on valueDifference.
         }


        // General evaluation based on value difference if not a special case
        let message;
        let className;

        if (valueDifference <= thresholds.optimal) {
            message = `${playerName} played a Super Move!${coordsString}`; // More enthusiastic
            className = 'feedback-optimal';
        } else if (valueDifference <= thresholds.good) {
            message = `${playerName} played a Good Move.${coordsString}`;
            className = 'feedback-good';
        } else if (valueDifference <= thresholds.okay) {
            message = `${playerName} played an Okay Move.${coordsString}`;
            className = 'feedback-okay';
        } else {
            message = `${playerName} played a Less Helpful Move.${coordsString}`; // Simpler wording
            className = 'feedback-suboptimal';
        }

         return { message: message, className: className, playerColor: playerColor };
    }

    // --- End Move Evaluation Feedback Logic ---


    async function handleMove(row, col) {
        // Only allow move if it's the current player's turn on the live board, no animation, not viewing history, and it's a valid move
        if (gameOver || animationInProgress || isViewingHistory || !isValidMove(row, col, currentPlayer)) {
            return;
        }

        stopTimer(); // Stop the current player's timer

        animationInProgress = true; // Block interaction

        // --- Feedback Step 1: Calculate possible moves and their values *before* the move ---
        const currentPlayerValidMovesWithFlips = getValidMoves(currentPlayer);
        let allCurrentPlayerMovesWithEvaluations = [];

        // Calculate evaluation value for each possible move's resulting state (from current player's perspective)
         for (const move of currentPlayerValidMovesWithFlips) {
              const [r, c] = [move[0], move[1]];
             const { newBoard: simulatedBoard } = flipPieces(r, c, currentPlayer, copyBoard(board));

             // Use minimaxNegamax on the resulting state. The value returned is from the perspective of
             // the player whose turn it would be *next* (the opponent). Negate it to get the value
             // from the perspective of the player who just moved (currentPlayer).
             const value = -minimaxNegamax(simulatedBoard, FEEDBACK_EVAL_DEPTH - 1, (currentPlayer === BLACK ? WHITE : BLACK), -Infinity, Infinity);

             allCurrentPlayerMovesWithEvaluations.push({ move: [r, c], value: value });
         }
        // --- End Feedback Step 1 ---


        // Perform the actual move on the global board
        const { newBoard, flippedPieces, placedPiece } = flipPieces(row, col, currentPlayer, board);

        placeSound.play();

        board = newBoard; // Update the global board state immediately

        // Render the board with the flips (animation)
        renderBoard(flippedPieces); // Trigger animation

        // Wait for the piece flip animation to finish
        await new Promise(resolve => setTimeout(resolve, 350)); // Match CSS transition + slight buffer

        // Update scores based on the final state after flips
        updateScores(board);

        // --- Feedback Step 2: Generate and Add Feedback Message ---
        let feedbackMessageObject = null;
        const playerWhoJustMovedColor = currentPlayer; // Store player color before switching
        const playerWhoJustMoved = (playerWhoJustMovedColor === player1.color) ? player1 : player2;

        if (placedPiece) { // Ensure a piece was actually placed
             // Calculate feedback based on the chosen move vs the best possible move we found earlier
             // Use the pre-calculated evaluations (which are from the playerWhoJustMovedColor's perspective)
             const feedback = getFeedback([placedPiece.x, placedPiece.y], allCurrentPlayerMovesWithEvaluations, playerWhoJustMovedColor);
             feedbackMessageObject = feedback; // Store the message object
        }
        // --- End Feedback Step 2 ---


        // Switch to the next player *before* adding the history entry
        // The state we capture should reflect the board *after* the move, with the *next* player's turn indicated.
        switchPlayer(); // Switch currentPlayer
        updatePlayerDisplay();


        // Add the completed move's entry to history
        // Pass the placed piece coords and the feedback message object
         if (feedbackMessageObject) {
              // Add the specific move feedback message
              addHistoryEntry(placedPiece, feedbackMessageObject.message, feedbackMessageObject.class, feedbackMessageObject.playerColor);
         } else {
              // Should theoretically not happen for a valid move, but as fallback:
             addHistoryEntry(placedPiece, `${playerWhoJustMoved.name} played at (${row}, ${col})`, '', playerWhoJustMovedColor); // Basic message
         }


        const gameEndedAfterMove = checkGameOver();

        // Re-render board for the next player's turn.
        // Pass an empty array for animation pieces.
        // The dot and history messages will be rendered based on the info stored in the history (gameHistory, skipHistory, currentHistoryIndex).
        renderBoard([]); // Clears animation, relies on history for dot and hints for next player


        animationInProgress = false; // Re-enable interaction

        if (gameEndedAfterMove) return;

        if (!isViewingHistory) { // Only trigger next player's turn/skip if game is not over and not viewing history
             setTimeout(async () => {
                 if (!gameOver && !isViewingHistory && !animationInProgress) {
                     await checkForAutoSkip(); // checkForAutoSkip starts the timer for the next player if moves available
                 }
             }, 50); // Small delay before checking for next player's turn/skip
        }
    }


    // createBoardElements: Creates the empty DOM grid. Piece elements added/removed by renderBoard.
    function createBoardElements() {
        const boardElement = document.getElementById('board');
        if (!boardElement) {
            console.error("Board element #board not found!");
            return;
        }
        boardElement.innerHTML = '';
        cells = [];

        for (let i = 0; i < BOARD_SIZE; i++) {
            const rowCells = [];
            for (let j = 0; j < BOARD_SIZE; j++) {
                const cellElement = document.createElement('div');
                cellElement.className = 'cell';
                cellElement.addEventListener('click', () => handleMove(i, j));

                 // Add corner dot class here if it's a corner cell
                 if (isCorner(i, j)) {
                     cellElement.classList.add('corner-dot');
                 }

                boardElement.appendChild(cellElement);
                rowCells.push(cellElement);
            }
            cells.push(rowCells);
        }
    }

    function initializeGame() {
        gameOver = false;
        animationInProgress = false;
        isViewingHistory = false; // Ensure history view is off
        stopTimer(); // Ensure any old timer is stopped

        loadPlayerSetup(); // Load player names and colors and set initial currentPlayer

        board = initializeBoard();
        scores = {black: 2, white: 2};
        skipHistory = []; // Clear skip history
        gameHistory = []; // Clear game history
        currentHistoryIndex = -1; // Reset history index


        // Add the initial "Game Start" entry to history
        addHistoryEntry(null, "Game Start! Good Luck!", 'system-message', null); // Use system-message class


        createBoardElements();
        updateScores(board);
        updatePlayerDisplay();
        // updateSkipHistoryDisplay is called by addHistoryEntry


        document.getElementById('game-over').innerHTML = '';


        // Render the initial board state. Pass empty array for animation pieces.
        // renderBoard reads history state 0 for dots (null).
        renderBoard([]);

        updateHistoryButtonStates(); // Ensure buttons are disabled initially


         if (toggleHintsDropdownLink) {
            toggleHintsDropdownLink.textContent = showHints ? 'Hide Hints' : 'Show Hints';
        }

        // Initial check for auto-skip and start timer after a slight delay
         setTimeout(async () => {
            if (!gameOver && !isViewingHistory && !animationInProgress) {
                 await checkForAutoSkip(); // checkForAutoSkip starts the timer for the current player if moves are available
            }
        }, 100); // Small delay before starting game flow
    }

    // initializeGame is called from DOMContentLoaded.
</script>
</body>
</html>